VERSIONING TAGS: Milestones are taged with msX.X.X.X, releases are tagged vX.X.X.  Note that milestones always have a fourth number that indicates the specific milestone.  For example before the first release the release is v0.0.0 so all prerelease milestones start with this.  The fourth prerelease milestone would be ms0.0.0.4.

Consider making defun aliases for the different layers of an interface, e.g. defun-highlevel, so that documentation can be generated easier

I want to set up the API so that the specific pacakges (e.g. collection.list, collection.hash) have the most efficient implementation possible, while the top level uses almost exclusively generic functions, so that users can create objects that the "built in" functions work on.  Note that common lisp built in functions are always prefered over custom ones since they can be implemented much more efficiently (but if I find I can match them, then this restriction relaxes).  For example, even though e.g. remove works on lists *or* arrays, I still prefer using it as the "efficient" remove over writing one for each.

Note: 'inc! and dec! should also be generic functions at the top level so users can create objects that act like indexes.  There needs to be a "math" package or something where users can have the one that doesn't take a dispatch if they want.

Note that the hash version of get takes a default value to return if the key doesn't exist.  Map should do this as well.

We should also consider a "deep-copy" that does a deeper copy than the default (e.g. copy-tree vs. copy-list).  In many cases it just aliases with regular copy (or maybe I'll just define it for list)

We'll have to get some experience with array to see if the current syntax is ok or if (defun get (array &rest indexes)) would be better.  We can do that because we have to use apply in any case.  The problem is that it can't be consistant with generic get then.

I will probably want to create my own defgeneric that allows the defaults to be declared in the defgeneric call, since that makes more sense.  If a method doesn't define any, what was defined in the defgeneric is used, but defmethod always overrides if spcified.  I could create my own generic function object to ensure that I have to do the minimal work.  That way the normal method detection (with the lambda list) works properly, and then I add the defaults to the method after the fact.

UPDATE: This wont work because then you could never define a generic method that didn't have default values

I want to make destructive versions of functions that destroy their arguments be noted with a ' (to indicate a more efficient version of the function) and ! for functions that modify their argument (but it can be used afterward).  I would have to use e.g ^ instead of ' since ' is the quote operator

NOTE: hash.keys and hash.values do not provide a map function.  This is because it is not clear what kind of result they should return.

I am considering changing some of the functions that want an output spec to continue to function that way and do the generic dispatch based on the symbol.  At least concatenate should work like this

Go back and make sure all function arguments are as consistant as possible

NOTE: cl-user doesn't export anything, so std-user shouldn't either.  Just collect all the packages